/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/models/puzzle.glb 
Author: tkkjee â€‹ðŸ¥€ (https://sketchfab.com/tkkjee)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/puzzle-dc079e8e016748a6bc1e783e07b07cd5
Title: Puzzle
*/

import React, { useRef, useState } from 'react'
import { useGLTF,Scroll, ScrollControls } from '@react-three/drei'
import { useFrame } from 'react-three-fiber';
import {useNavigate } from 'react-router-dom';




// // Define the ParticipateButton component
// const ParticipateButton = ({ onStopRotation}) => {
//     const [isHovered, setIsHovered] = useState(false);
  
//     return (
//       <Html>
//         <div
//           className={`participate-button ${isHovered ? 'hovered' : ''}`}
//           onMouseEnter={() => {
//             setIsHovered(true);
//             onStopRotation(true);
//           }}
//           onMouseLeave={() => {
//             setIsHovered(false);
//             onStopRotation(false);
//           }}
//         >
//           Participate
//         </div>
//       </Html>
//     );
//   };
  

export function Puzzle_Model(props) {
    const group = useRef();
  const { nodes, materials } = useGLTF('./models/puzzle.glb');
  const [stopRotation, setStopRotation] = useState(false);
  const [isButtonCLicked, setIsButtonCliked] = useState(false);
  const navigate = useNavigate();
  
  // Use useFrame to update rotation on each frame
  useFrame(() => {
    if (!stopRotation) {
      group.current.rotation.y += 0.02; // Adjust the rotation speed as needed
    }
  });

  // // Function to stop or resume rotation based on the button's hover state
  // const handleStopRotation = (shouldStop) => {
  //   setStopRotation(shouldStop);
  // };

  const [targetPosition, setTargetPosition] = useState([0, 0.5, 0]);
  const rate = 0.7; // Adjust the rate as needed
  // Use useRef for mutable values that do not trigger a re-render
  const currentPosition = useRef([...targetPosition]);
  useFrame((state, delta) => {
    // Gradually increase the Z-axis position value
    currentPosition.current[2] += rate * delta;

    // Ensure the position doesn't go beyond the target value
    if (currentPosition.current[2] > targetPosition[2]) {
      currentPosition.current[2] = targetPosition[2];
      //navigate('/events');
    }
    if(currentPosition.current[2] === targetPosition[2] && isButtonCLicked) {
      navigate('/events');
    }

    // Apply the updated position to the group
    group.current.position.set(...currentPosition.current);
  });
  const positon =[0,0.5,0];
  const handleButtonClick = () => {
    // Update the target position to move the model upward
    setTargetPosition([0, 0.5,6]);
    setStopRotation(true);
    setIsButtonCliked(true);
    console.log(targetPosition);
  };


  return (
    <>
    <group {...props} dispose={null} scale={1.5}  ref={group} position={positon}>
      <group rotation={[0, 0, -0.386]} scale={2.335}>
        <mesh geometry={nodes.Object_5.geometry} material={materials.material} position={[0, 0, -0.245]} rotation={[Math.PI / 2, 0, 0]} scale={0.428} />
        <mesh geometry={nodes.Object_7.geometry} material={materials.green} position={[0, 0, 0.083]} rotation={[Math.PI / 2, 0, 0]} scale={0.428} />
        <mesh geometry={nodes.Object_9.geometry} material={materials.blue} position={[0, 0, 0.054]} rotation={[Math.PI / 2, 0, 0]} scale={0.428} />
        <mesh geometry={nodes.Object_11.geometry} material={materials.blue} position={[0, 0, 0.022]} rotation={[Math.PI / 2, 0, 0]} scale={0.428} />
      </group>
      <group position={[-0.561, -0.962, 0.534]} rotation={[0, 0, 0.041]} scale={1.292}>
        <mesh geometry={nodes.Object_13.geometry} material={materials.cloud} />
        <mesh geometry={nodes.Object_15.geometry} material={materials.cloud} position={[0.402, -0.031, 0]} rotation={[0, 0, -0.161]} scale={[-0.603, 0.603, 0.603]} />
      </group>
      <group position={[1.075, -0.635, 0.945]} rotation={[0.307, -1.133, 0]} scale={0.069}>
        <mesh geometry={nodes.Object_17.geometry} material={materials.cloud} />
        <mesh geometry={nodes.Object_19.geometry} material={materials.cloud} position={[1.512, -0.982, -2.496]} rotation={[0.327, -0.745, 0.238]} scale={[-0.522, 0.522, 0.522]} />
      </group>
      <group position={[0.522, 0.915, -0.336]} rotation={[-Math.PI, 0, -3.059]} scale={0.847}>
        <mesh geometry={nodes.Object_21.geometry} material={materials.cloud} />
        <mesh geometry={nodes.Object_23.geometry} material={materials.cloud} position={[0.402, -0.031, 0]} rotation={[0, 0, -0.161]} scale={[-0.603, 0.603, 0.603]} />
      </group>
      <mesh geometry={nodes.Object_25.geometry} material={materials['Material.001']} position={[1.045, -0.753, 1.152]} scale={0.162} />
      <mesh geometry={nodes.Object_27.geometry} material={materials['Material.001']} position={[-0.458, 0.633, 0.618]} scale={0.137} />
      <mesh geometry={nodes.Object_29.geometry} material={materials['Material.001']} position={[-0.244, 1.89, -1.942]} scale={0.514} />
    </group>
    {/* <ParticipateButton className='participate-button' onStopRotation={handleStopRotation} onClick={handleButtonClick}  /> */}
    <ScrollControls pages={0} damping={0.25}>
    <Scroll html>
      <button className='participate-button' onClick={handleButtonClick}>Participate</button>

    </Scroll>
    </ScrollControls>
    </>
  )
}

useGLTF.preload('./models/puzzle.glb')
